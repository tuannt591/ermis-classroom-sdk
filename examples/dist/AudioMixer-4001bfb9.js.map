{"version":3,"file":"AudioMixer-4001bfb9.js","sources":["../src/media/AudioMixer.js"],"sourcesContent":["/**\n * AudioMixer Class for combining multiple subscriber audio streams\n * Provides centralized audio mixing and playback management\n */\nclass AudioMixer {\n  constructor(config = {}) {\n    this.audioContext = null;\n    this.mixerNode = null;\n    this.outputDestination = null;\n    this.subscriberNodes = new Map(); // subscriberId -> AudioWorkletNode\n    this.isInitialized = false;\n    this.outputAudioElement = null;\n\n    // Configuration\n    this.masterVolume = config.masterVolume || 0.8;\n    this.sampleRate = config.sampleRate || 48000;\n    this.bufferSize = config.bufferSize || 256;\n    this.enableEchoCancellation = config.enableEchoCancellation !== false;\n    this.debug = config.debug || false;\n  }\n\n  /**\n   * Initialize the audio mixer\n   */\n  async initialize() {\n    if (this.isInitialized) {\n      this._debug(\"AudioMixer already initialized\");\n      return;\n    }\n\n    try {\n      // Create shared AudioContext\n      this.audioContext = new (window.AudioContext ||\n        window.webkitAudioContext)({\n        sampleRate: this.sampleRate,\n        latencyHint: \"interactive\",\n      });\n\n      // Resume context if suspended (required by some browsers)\n      if (this.audioContext.state === \"suspended\") {\n        await this.audioContext.resume();\n      }\n\n      // Create mixer node (GainNode to combine audio)\n      this.mixerNode = this.audioContext.createGain();\n      this.mixerNode.gain.value = this.masterVolume;\n\n      // Create output destination\n      this.outputDestination = this.audioContext.createMediaStreamDestination();\n      this.mixerNode.connect(this.outputDestination);\n\n      // Create hidden audio element for mixed audio playback\n      this.outputAudioElement = document.createElement(\"audio\");\n      this.outputAudioElement.autoplay = true;\n      this.outputAudioElement.style.display = \"none\";\n      this.outputAudioElement.setAttribute(\"playsinline\", \"\");\n\n      // Disable echo cancellation on output element\n      if (this.enableEchoCancellation) {\n        this.outputAudioElement.setAttribute(\"webkitAudioContext\", \"true\");\n      }\n\n      document.body.appendChild(this.outputAudioElement);\n\n      this.isInitialized = true;\n      this._debug(\"AudioMixer initialized successfully\");\n\n      // Setup error handlers\n      this._setupErrorHandlers();\n    } catch (error) {\n      console.error(\"Failed to initialize AudioMixer:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Add a subscriber's audio stream to the mixer\n   */\n  async addSubscriber(\n    subscriberId,\n    audioWorkletUrl,\n    isOwnAudio = false,\n    channelWorkletPort\n  ) {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n\n    // Skip adding own audio to prevent echo/feedback\n    if (isOwnAudio) {\n      this._debug(\n        `Skipping own audio for subscriber ${subscriberId} to prevent echo`\n      );\n      return null;\n    }\n\n    // Check if subscriber already exists\n    if (this.subscriberNodes.has(subscriberId)) {\n      this._debug(`Subscriber ${subscriberId} already exists in mixer`);\n      return this.subscriberNodes.get(subscriberId);\n    }\n\n    try {\n      // Load audio worklet if not already loaded\n      await this._loadAudioWorklet(audioWorkletUrl);\n\n      // Create AudioWorkletNode for this subscriber\n      const workletNode = new AudioWorkletNode(\n        this.audioContext,\n        \"jitter-resistant-processor\",\n        {\n          numberOfInputs: 0,\n          numberOfOutputs: 1,\n          outputChannelCount: [2],\n        }\n      );\n\n      // Connect the port if provided\n      if (channelWorkletPort) {\n        workletNode.port.postMessage(\n          { type: \"connectWorker\", port: channelWorkletPort },\n          [channelWorkletPort]\n        );\n      }\n\n      // Create gain node for individual volume control\n      const gainNode = this.audioContext.createGain();\n      gainNode.gain.value = 1.0;\n\n      // Connect: workletNode -> gainNode -> mixerNode\n      workletNode.connect(gainNode);\n      gainNode.connect(this.mixerNode);\n\n      // Store reference with gain node\n      this.subscriberNodes.set(subscriberId, {\n        workletNode,\n        gainNode,\n        isActive: true,\n        addedAt: Date.now(),\n      });\n\n      // Update audio element source with mixed stream\n      this._updateOutputAudio();\n\n      // Setup message handler\n      this._setupWorkletMessageHandler(subscriberId, workletNode);\n\n      this._debug(`Added subscriber ${subscriberId} to audio mixer`);\n      return workletNode;\n    } catch (error) {\n      console.error(\n        `Failed to add subscriber ${subscriberId} to mixer:`,\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Remove a subscriber from the mixer\n   */\n  removeSubscriber(subscriberId) {\n    const subscriberData = this.subscriberNodes.get(subscriberId);\n    if (!subscriberData) {\n      this._debug(`Subscriber ${subscriberId} not found in mixer`);\n      return false;\n    }\n\n    try {\n      const { workletNode, gainNode } = subscriberData;\n\n      // Disconnect nodes\n      workletNode.disconnect();\n      gainNode.disconnect();\n\n      // Remove from map\n      this.subscriberNodes.delete(subscriberId);\n\n      // Update audio element if no more subscribers\n      this._updateOutputAudio();\n\n      this._debug(`Removed subscriber ${subscriberId} from audio mixer`);\n      return true;\n    } catch (error) {\n      console.error(`Failed to remove subscriber ${subscriberId}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Set volume for a specific subscriber\n   */\n  setSubscriberVolume(subscriberId, volume) {\n    const subscriberData = this.subscriberNodes.get(subscriberId);\n    if (!subscriberData) {\n      this._debug(`Subscriber ${subscriberId} not found for volume adjustment`);\n      return false;\n    }\n\n    try {\n      const normalizedVolume = Math.max(0, Math.min(1, volume));\n      subscriberData.gainNode.gain.value = normalizedVolume;\n\n      this._debug(\n        `Set volume for subscriber ${subscriberId}: ${normalizedVolume}`\n      );\n      return true;\n    } catch (error) {\n      console.error(\n        `Failed to set volume for subscriber ${subscriberId}:`,\n        error\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Mute/unmute a specific subscriber\n   */\n  setSubscriberMuted(subscriberId, muted) {\n    return this.setSubscriberVolume(subscriberId, muted ? 0 : 1);\n  }\n\n  /**\n   * Set master volume for all mixed audio\n   */\n  setMasterVolume(volume) {\n    if (!this.mixerNode) return false;\n\n    try {\n      const normalizedVolume = Math.max(0, Math.min(1, volume));\n      this.mixerNode.gain.value = normalizedVolume;\n      this.masterVolume = normalizedVolume;\n\n      this._debug(`Set master volume: ${normalizedVolume}`);\n      return true;\n    } catch (error) {\n      console.error(\"Failed to set master volume:\", error);\n      return false;\n    }\n  }\n\n  /**\n   * Get mixed audio output stream\n   */\n  getOutputMediaStream() {\n    if (!this.outputDestination) {\n      this._debug(\"Output destination not initialized\");\n      return null;\n    }\n    return this.outputDestination.stream;\n  }\n\n  /**\n   * Get current mixer statistics\n   */\n  getStats() {\n    return {\n      isInitialized: this.isInitialized,\n      subscriberCount: this.subscriberNodes.size,\n      masterVolume: this.masterVolume,\n      audioContextState: this.audioContext?.state || \"not-initialized\",\n      sampleRate: this.audioContext?.sampleRate || 0,\n      subscribers: Array.from(this.subscriberNodes.entries()).map(\n        ([id, data]) => ({\n          id,\n          volume: data.gainNode.gain.value,\n          isActive: data.isActive,\n          addedAt: data.addedAt,\n        })\n      ),\n    };\n  }\n\n  /**\n   * Get list of subscriber IDs\n   */\n  getSubscriberIds() {\n    return Array.from(this.subscriberNodes.keys());\n  }\n\n  /**\n   * Check if subscriber exists in mixer\n   */\n  hasSubscriber(subscriberId) {\n    return this.subscriberNodes.has(subscriberId);\n  }\n\n  /**\n   * Suspend audio context (for battery saving)\n   */\n  async suspend() {\n    if (this.audioContext && this.audioContext.state === \"running\") {\n      await this.audioContext.suspend();\n      this._debug(\"Audio context suspended\");\n    }\n  }\n\n  /**\n   * Resume audio context\n   */\n  async resume() {\n    if (this.audioContext && this.audioContext.state === \"suspended\") {\n      await this.audioContext.resume();\n      this._debug(\"Audio context resumed\");\n    }\n  }\n\n  /**\n   * Cleanup mixer resources\n   */\n  async cleanup() {\n    this._debug(\"Starting AudioMixer cleanup\");\n\n    try {\n      // Remove audio element\n      if (this.outputAudioElement) {\n        this.outputAudioElement.srcObject = null;\n        if (this.outputAudioElement.parentNode) {\n          this.outputAudioElement.parentNode.removeChild(\n            this.outputAudioElement\n          );\n        }\n        this.outputAudioElement = null;\n      }\n\n      // Disconnect all subscribers\n      for (const [subscriberId, subscriberData] of this.subscriberNodes) {\n        try {\n          const { workletNode, gainNode } = subscriberData;\n          workletNode.disconnect();\n          gainNode.disconnect();\n        } catch (error) {\n          console.error(\n            `Error disconnecting subscriber ${subscriberId}:`,\n            error\n          );\n        }\n      }\n      this.subscriberNodes.clear();\n\n      // Disconnect mixer components\n      if (this.mixerNode) {\n        this.mixerNode.disconnect();\n        this.mixerNode = null;\n      }\n\n      if (this.outputDestination) {\n        this.outputDestination = null;\n      }\n\n      // Close audio context\n      if (this.audioContext && this.audioContext.state !== \"closed\") {\n        await this.audioContext.close();\n      }\n\n      // Reset state\n      this.audioContext = null;\n      this.isInitialized = false;\n\n      this._debug(\"AudioMixer cleanup completed\");\n    } catch (error) {\n      console.error(\"Error during AudioMixer cleanup:\", error);\n    }\n  }\n\n  /**\n   * Load audio worklet module\n   */\n  async _loadAudioWorklet(audioWorkletUrl) {\n    try {\n      await this.audioContext.audioWorklet.addModule(audioWorkletUrl);\n      this._debug(\"Audio worklet loaded:\", audioWorkletUrl);\n    } catch (error) {\n      // Worklet might already be loaded\n      if (!error.message.includes(\"already been loaded\")) {\n        this._debug(\"Audio worklet load warning:\", error.message);\n      }\n    }\n  }\n\n  /**\n   * Update output audio element\n   */\n  _updateOutputAudio() {\n    if (!this.outputAudioElement || !this.outputDestination) return;\n\n    try {\n      if (this.subscriberNodes.size > 0) {\n        this.outputAudioElement.srcObject = this.outputDestination.stream;\n      } else {\n        this.outputAudioElement.srcObject = null;\n      }\n    } catch (error) {\n      console.error(\"Failed to update output audio:\", error);\n    }\n  }\n\n  /**\n   * Setup message handler for worklet node\n   */\n  _setupWorkletMessageHandler(subscriberId, workletNode) {\n    workletNode.port.onmessage = (event) => {\n      const { type, bufferMs, isPlaying, newBufferSize, error } = event.data;\n\n      switch (type) {\n        case \"bufferStatus\":\n          this._debug(\n            `Subscriber ${subscriberId} buffer: ${bufferMs}ms, playing: ${isPlaying}`\n          );\n          break;\n        case \"bufferSizeChanged\":\n          this._debug(\n            `Subscriber ${subscriberId} buffer size changed: ${newBufferSize}`\n          );\n          break;\n        case \"error\":\n          console.error(`Subscriber ${subscriberId} worklet error:`, error);\n          break;\n        default:\n          this._debug(\n            `Subscriber ${subscriberId} worklet message:`,\n            event.data\n          );\n      }\n    };\n\n    workletNode.port.onerror = (error) => {\n      console.error(`Subscriber ${subscriberId} worklet port error:`, error);\n    };\n  }\n\n  /**\n   * Setup error handlers for audio context\n   */\n  _setupErrorHandlers() {\n    if (!this.audioContext) return;\n\n    this.audioContext.onstatechange = () => {\n      this._debug(`Audio context state changed: ${this.audioContext.state}`);\n\n      if (this.audioContext.state === \"interrupted\") {\n        console.warn(\"Audio context was interrupted\");\n      }\n    };\n\n    // Listen for audio context suspend/resume events\n    document.addEventListener(\"visibilitychange\", async () => {\n      if (document.hidden) {\n        // Page hidden - optionally suspend context\n        // await this.suspend();\n      } else {\n        // Page visible - resume context if needed\n        await this.resume();\n      }\n    });\n  }\n\n  /**\n   * Debug logging\n   */\n  _debug(...args) {\n    if (this.debug) {\n      console.log(\"[AudioMixer]\", ...args);\n    }\n  }\n\n  /**\n   * Sleep utility for delays\n   */\n  _sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\nexport default AudioMixer;\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;;;;"}